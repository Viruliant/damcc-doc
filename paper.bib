@COMMENT {@misc{ChannelName,
title = {Title},
url = {https://www.youtube.com/watch?v = XXXXXX},
journal = {YouTube},
author = {ChannelName}
year = {2000},
month = {Jan.}
}}

@inproceedings{10.1145/1985793.1985863,
author = {Milicevic, Aleksandar and Rayside, Derek and Yessenov, Kuat and Jackson, Daniel},
title = {Unifying Execution of Imperative and Declarative Code},
year = {2011},
isbn = {9781450304450},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://groups.csail.mit.edu/sdg/pubs/2011/icse11-squander.pdf},
doi = {10.1145/1985793.1985863},
abstract = {We present a unified environment for running declarative specifications in the context of an imperative object-Oriented programming language. Specifications are Alloy-like, written in first-order relational logic with transitive closure, and the imperative language is Java. By being able to mix imperative code with executable declarative specifications, the user can easily express constraint problems in place, i.e., in terms of the existing data structures and objects on the heap. After a solution is found, the heap is updated to reflect the solution, so the user can continue to manipulate the program heap in the usual imperative way. We show that this approach is not only convenient, but, for certain problems can also outperform a standard imperative implementation. We also present an optimization technique that allowed us to run our tool on heaps with almost 2000 objects.},
booktitle = {Proceedings of the 33rd International Conference on Software Engineering},
pages = {511–520},
numpages = {10},
keywords = {executable specifications, constraint-based languages, formal methods, declarative programming},
location = {Waikiki, Honolulu, HI, USA},
series = {ICSE '11}
}

@article{DBLP:journals/corr/abs-1007-2885,
  author    = {Adam Megacz},
  title     = {Multi-Level Languages are Generalized Arrows},
  journal   = {CoRR},
  volume    = {abs/1007.2885},
  year      = {2010},
  url       = {http://arxiv.org/abs/1007.2885},
  eprinttype = {arXiv},
  eprint    = {1007.2885},
  timestamp = {Mon, 13 Aug 2018 16:49:11 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-1007-2885.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{DBLP:journals/corr/abs-1003-5954,
  author    = {Adam Megacz},
  title     = {Multi-Stage Programs are Generalized Arrows},
  journal   = {CoRR},
  volume    = {abs/1003.5954},
  year      = {2010},
  url       = {http://arxiv.org/abs/1003.5954},
  eprinttype = {arXiv},
  eprint    = {1003.5954},
  timestamp = {Mon, 13 Aug 2018 16:46:32 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-1003-5954.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@COMMENT {
@misc{ComplexComputing_2009,
title = {How Complex is "Personal Computing"? - 2D Rendering (Gezira & Nile) - Domain-Specific Languages (OMeta) - Imperative & Declarative Programming (Programming as Planning, Executable Specifications)},
url = {https://www.youtube.com/watch?v=HAT4iewOHDs},
journal = {YouTube},
author = {Alan Kay, Dan Amelang, Alessandro Warth, Hesam Samimi},
year = {2009} }
}
@misc{Kay_video2009,
title = {How Complex is "Personal Computing"?},
url = {https://youtu.be/HAT4iewOHDs},
journal = {YouTube},
author = {Alan Kay},
year = {2009} }

@misc{Amelang_video2009,
title = {2D Rendering (Gezira & Nile)},
url = {https://youtu.be/HAT4iewOHDs?t=1025},
journal = {YouTube},
author = {Dan Amelang},
year = {2009} }

@misc{Warth_video2009,
title = {Domain-Specific Languages (OMeta)},
url = {https://youtu.be/HAT4iewOHDs?t=2060},
journal = {YouTube},
author = {Alessandro Warth},
year = {2009} }

@misc{Samimi_video2009,
title = {Imperative & Declarative Programming (Programming as Planning, Executable Specifications)},
url = {https://youtu.be/HAT4iewOHDs?t=3578},
journal = {YouTube},
author = {Hesam Samimi},
year = {2009} }

@misc{Piumarta_video2007,
title = {Building Your Own Dynamic Language},
url = {https://youtu.be/cn7kTPbW6QQ?t=2736},
journal = {YouTube},
author = {Ian Piumarta},
year = {2007} }

@misc{ClickNodes,
title = {The Sea of Nodes and the HotSpot JIT},
url = {https://youtu.be/9epgZ-e6DUU?t=3535},
journal = {YouTube},
author = {Cliff Click},
year = {2020}}

@inproceedings{10.5555/1267847.1267848,
author = {Paleczny, Michael and Vick, Christopher and Click, Cliff},
title = {The Java HotspotTM Server Compiler},
year = {2001},
publisher = {USENIX Association},
address = {USA},
abstract = {The Java HotSpotTM Server Compiler achieves improved asymptotic performance through a combination of object-oriented and classical-compiler optimizations. Aggressive inlining using class-hierarchy analysis reduces function call overhead and provides opportunities for many compiler optimizations.},
booktitle = {Proceedings of the 2001 Symposium on JavaTM Virtual Machine Research and Technology Symposium - Volume 1},
pages = {1},
numpages = {1},
location = {Monterey, California},
series = {JVM'01}
}

@article{10.1145/872726.806984,
author = {Chaitin, G. J.},
title = {Register Allocation &amp; Spilling via Graph Coloring},
year = {1982},
issue_date = {June 1982},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {17},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/872726.806984},
doi = {10.1145/872726.806984},
abstract = {In a previous paper we reported the successful use of graph coloring techniques for doing global register allocation in an experimental PL/I optimizing compiler. When the compiler cannot color the register conflict graph with a number of colors equal to the number of available machine registers, it must add code to spill and reload registers to and from storage. Previously the compiler produced spill code whose quality sometimes left much to be desired, and the ad hoe techniques used took considerable amounts of compile time. We have now discovered how to extend the graph coloring approach so that it naturally solves the spilling problem. Spill decisions are now made on the basis of the register conflict graph and cost estimates of the value of keeping the result of a computation in a register rather than in storage. This new approach produces better object code and takes much less compile time.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {98–101},
numpages = {4}
}

@inproceedings{10.1145/800230.806984,
author = {Chaitin, G. J.},
title = {Register Allocation &amp; Spilling via Graph Coloring},
year = {1982},
isbn = {0897910745},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800230.806984},
doi = {10.1145/800230.806984},
abstract = {In a previous paper we reported the successful use of graph coloring techniques for doing global register allocation in an experimental PL/I optimizing compiler. When the compiler cannot color the register conflict graph with a number of colors equal to the number of available machine registers, it must add code to spill and reload registers to and from storage. Previously the compiler produced spill code whose quality sometimes left much to be desired, and the ad hoe techniques used took considerable amounts of compile time. We have now discovered how to extend the graph coloring approach so that it naturally solves the spilling problem. Spill decisions are now made on the basis of the register conflict graph and cost estimates of the value of keeping the result of a computation in a register rather than in storage. This new approach produces better object code and takes much less compile time.},
booktitle = {Proceedings of the 1982 SIGPLAN Symposium on Compiler Construction},
pages = {98–105},
numpages = {8},
location = {Boston, Massachusetts, USA},
series = {SIGPLAN '82}
}

@inproceedings{10.1145/2068776.2068778,
author = {Piumarta, Ian},
title = {Open, Extensible Composition Models},
year = {2011},
isbn = {9781450308922},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2068776.2068778},
doi = {10.1145/2068776.2068778},
abstract = {Simple functional languages like LISP are useful for exploring novel semantics and composition mechanisms. That usefulness can be limited by the assumptions built into the evaluator about the structure of data and the meaning of expressions. These assumptions create difficulties when a program introduces a composition mechanism that differs substantially from the built-in mechanism of function application. We explore how an evaluator can be constructed to eliminate most built-in assumptions about meaning, and show how new composition mechanisms can be introduced easily and seamlessly into the language it evaluates.},
booktitle = {Proceedings of the 1st International Workshop on Free Composition},
articleno = {2},
numpages = {5},
location = {Lancaster, United Kingdom},
series = {FREECO '11}
}

@inproceedings{10.1145/2068776.2068779,
author = {Piumarta, Ian},
title = {An Association-Based Model of Dynamic Behaviour},
year = {2011},
isbn = {9781450308922},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2068776.2068779},
doi = {10.1145/2068776.2068779},
abstract = {Dynamic programming languages seem to spend much of their time looking up behaviour associatively. Data structures in these languages are also easily expressible as associations. We propose that many, and maybe even all, interesting organisations of information and behaviour might be built from a single primitive operation: n-way associative lookup. A fast implementation of this primitive, possibly in hardware, could be the basis of efficient and compact implementations of a diverse range of programming language semantics and data structures.},
booktitle = {Proceedings of the 1st International Workshop on Free Composition},
articleno = {3},
numpages = {5},
location = {Lancaster, United Kingdom},
series = {FREECO '11}
}

@inproceedings{10.1145/1942793.1942796,
author = {Piumarta, Ian},
title = {PEG-Based Transformer Provides Front-, Middle-and Back-End Stages in a Simple Compiler},
year = {2010},
isbn = {9781450304917},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1942793.1942796},
doi = {10.1145/1942793.1942796},
abstract = {Traditional compiler generators target a single stage within the compilation process. Each generator typically uses a dedicated specification language and the generated code often imposes restrictions on the program representation accepted as input or generated as output. This makes compilers larger and more complex than they need to be. We present a simple compiler that unifies specification and implementation of all its stages, using PEG-based transformations on a single, versatile representation. The resulting compiler is small, easy to understand, and highly suited to implementing its own implementation language.},
booktitle = {Workshop on Self-Sustaining Systems},
pages = {10–20},
numpages = {11},
location = {Tokyo, Japan},
series = {S3 '10}
}

@inbook{10.1007/978-3-540-89275-5_1,
author = {Piumarta, Ian and Warth, Alessandro},
title = {Open, Extensible Object Models},
year = {2008},
isbn = {9783540892748},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-540-89275-5_1},
abstract = {Programming languages often hide their implementation at a level of abstraction that is inaccessible to programmers. Decisions and tradeoffs made by the language designer at this level (single vs. multiple inheritance, mixins vs. Traits, dynamic dispatch vs. static case analysis, etc.) cannot be repaired easily by the programmer when they prove inconvenient or inadequate. The artificial distinction between implementation language and end-user language can be eliminated by implementing the language using only end-user objects and messages, making the implementation accessible for arbitrary modification by programmers. We show that three object types and five methods are sufficient to bootstrap an extensible object model and messaging semantics that are described entirely in terms of those same objects and messages. Raising the implementation to the programmers' level lets them design and control their own implementation mechanisms in which to express concise solutions and frees the original language designer from ever having to say "I'm sorry".},
booktitle = {Self-Sustaining Systems: First Workshop, S3 2008 Potsdam, Germany, May 15-16, 2008 Revised Selected Papers},
pages = {1–30},
numpages = {30}
}

@inproceedings{10.1145/1297081.1297086,
author = {Warth, Alessandro and Piumarta, Ian},
title = {OMeta: An Object-Oriented Language for Pattern Matching},
year = {2007},
isbn = {9781595938688},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1297081.1297086},
doi = {10.1145/1297081.1297086},
abstract = {This paper introduces OMeta, a new object-oriented language for pattern matching. OMeta is based on a variant of Parsing Expression Grammars (PEGs) [5]---a recognition-based foundation for describing syntax---which we have extended to handle arbitrary kinds of data. We show that OMeta's general-purpose pattern matching provides a natural and convenient way for programmers to implement tokenizers, parsers, visitors, and tree transformers, all of which can be extended in interesting ways using familiar object-oriented mechanisms. This makes OMeta particularly well-suited as a medium for experimenting with new designs for programming languages and extensions to existing languages.},
booktitle = {Proceedings of the 2007 Symposium on Dynamic Languages},
pages = {11–19},
numpages = {9},
keywords = {metacircular implementation, parsing, pattern matching},
location = {Montreal, Quebec, Canada},
series = {DLS '07}
}

@inproceedings{10.5555/1267242.1267250,
author = {Piumarta, Ian},
title = {The Virtual Processor: Fast, Architecture-Neutral Dynamic Code Generation},
year = {2004},
publisher = {USENIX Association},
address = {USA},
abstract = {Tools supporting dynamic code generation tend too be low-level (leaving much work to the client application) or too intimately related with the language/system in which they are used (making them unsuitable for casual reuse). Applications or virtual machines wanting to benefit from runtime code generation are therefore forced to implement much of the compilation chain for themselves even when they make use of the available tools. The VPU is an fast, high-level code generation utility that performs most of the complex tasks related to code generation, including register allocation, and which produces good-quality C ABI-compliant native code. In the simplest cases, adding VPU-based runtime code generation to an application requires just a few lines of additional code--and for a typical virtual machine, VPU-based just-in-time compilation requires only a few lines of code per virtual instruction.},
booktitle = {Proceedings of the 3rd Conference on Virtual Machine Research And Technology Symposium - Volume 3},
pages = {8},
numpages = {1},
location = {San Jose, California},
series = {VM'04}
}
